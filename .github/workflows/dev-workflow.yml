name: Dev Workflow - Ephemeral DB

on:
  push:
    branches:
      - dev

permissions:
  id-token: write
  contents: read

jobs:

  provision-ephemeral-db:
    name: Provision Ephemeral DB from Prod Snapshot
    runs-on: ubuntu-latest
    outputs:
      db_endpoint: ${{ steps.restore_db.outputs.db_endpoint }}
      temp_s3_bucket: ${{ steps.identifiers.outputs.temp_s3_bucket }}
      temp_secret_name: ${{ steps.new-db-password.outputs.temp_secret_name }}
    env:
      AWS_REGION: us-east-1
      PROD_DB_INSTANCE_IDENTIFIER: "radsolutions-db"
      AWS_ACCOUNT_ID: 978368259161
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActions-deploy-role
          aws-region: ${{ env.AWS_REGION }}
      - name: Generate unique identifiers for this run
        id: identifiers
        run: |
          TIMESTAMP=$(date +%s)
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-8)
          UNIQUE_ID="dev-${SHORT_SHA}-${TIMESTAMP}"
          echo "snapshot_id=snapshot-${UNIQUE_ID}" >> $GITHUB_OUTPUT
          echo "temp_db_id=temp-db-${UNIQUE_ID}" >> $GITHUB_OUTPUT
          echo "temp_s3_bucket=radsolutions-media-uploads-${UNIQUE_ID}" >> $GITHUB_OUTPUT
          echo "temp_secret_name=temp-secret-${UNIQUE_ID}" >> $GITHUB_OUTPUT
          echo "Generated Snapshot ID: snapshot-${UNIQUE_ID}"
          echo "Generated Temp DB ID: temp-db-${UNIQUE_ID}"
          echo "Generated Temp S3 Bucket: radsolutions-media-uploads-${UNIQUE_ID}"
          echo "Generated Temp Secret Name: temp-secret-${UNIQUE_ID}"
      - name: Create DB Snapshot from Production
        run: |
          echo "Starting snapshot of ${{ env.PROD_DB_INSTANCE_IDENTIFIER }}..."
          aws rds create-db-snapshot \
            --db-instance-identifier ${{ env.PROD_DB_INSTANCE_IDENTIFIER }} \
            --db-snapshot-identifier ${{ steps.identifiers.outputs.snapshot_id }} \
            --tags Key=SourceWorkflow,Value="${{ github.workflow }}" Key=CommitSHA,Value=${{ github.sha }}
          echo "Waiting for snapshot to be available..."
          aws rds wait db-snapshot-available --db-snapshot-identifier ${{ steps.identifiers.outputs.snapshot_id }}
          echo "Snapshot ${{ steps.identifiers.outputs.snapshot_id }} is available."
      - name: Restore DB Instance from Snapshot
        id: restore_db
        run: |
          echo "Restoring snapshot to a new temporary DB instance..."
          aws rds restore-db-instance-from-db-snapshot \
            --db-instance-identifier ${{ steps.identifiers.outputs.temp_db_id }} \
            --db-snapshot-identifier ${{ steps.identifiers.outputs.snapshot_id }} \
            --db-instance-class db.t3.micro \
            --no-publicly-accessible \
            --vpc-security-group-ids sg-003e52293c66d330d \
            --db-subnet-group-name default-vpc-096cb4bbbbbf1b1be \
            --tags Key=SourceWorkflow,Value="${{ github.workflow }}" Key=CommitSHA,Value=${{ github.sha }}
          echo "Waiting for temporary DB instance to be available..."
          aws rds wait db-instance-available --db-instance-identifier ${{ steps.identifiers.outputs.temp_db_id }}
          DB_ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier ${{ steps.identifiers.outputs.temp_db_id }} --query "DBInstances[0].Endpoint.Address" --output text)
          echo "db_endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT
          echo "Temporary DB is available at: $DB_ENDPOINT"
      - name: Generate and Set New DB Password
        id: new-db-password
        run: |
          echo "Generating a new random password for the temporary DB..."
          NEW_DB_PASSWORD=$(openssl rand -hex 16) # Use hex to generate a 32-char compliant password
          echo "::add-mask::$NEW_DB_PASSWORD"
          echo "Storing new password in a temporary secret..."
          aws secretsmanager create-secret \
            --name ${{ steps.identifiers.outputs.temp_secret_name }} \
            --secret-string "{\"password\":\"$NEW_DB_PASSWORD\"}" \
            --tags Key=SourceWorkflow,Value="${{ github.workflow }}" Key=CommitSHA,Value=${{ github.sha }}
          echo "Updating the temporary DB instance with the new password..."
          aws rds modify-db-instance \
            --db-instance-identifier ${{ steps.identifiers.outputs.temp_db_id }} \
            --master-user-password "$NEW_DB_PASSWORD" \
            --apply-immediately
          echo "Waiting for DB instance to finish modification..."
          aws rds wait db-instance-available --db-instance-identifier ${{ steps.identifiers.outputs.temp_db_id }}
          echo "Temporary DB password has been updated and stored securely."
          echo "temp_secret_name=${{ steps.identifiers.outputs.temp_secret_name }}" >> $GITHUB_OUTPUT
      - name: Create temporary S3 bucket for media
        run: |
          echo "Creating temporary S3 bucket: ${{ steps.identifiers.outputs.temp_s3_bucket }}"
          aws s3api create-bucket --bucket ${{ steps.identifiers.outputs.temp_s3_bucket }} --region ${{ env.AWS_REGION }}
          echo "Cloning media from production bucket to temporary bucket..."
          aws s3 sync s3://radsolutions-media-uploads-2253 s3://${{ steps.identifiers.outputs.temp_s3_bucket }}
          echo "Temporary S3 bucket ready: ${{ steps.identifiers.outputs.temp_s3_bucket }}"
          # Puedes exportar el nombre del bucket temporal como variable de entorno para otros jobs/steps si lo necesitas

  build-and-push-ecr:
    name: Build and Push to ECR
    runs-on: ubuntu-latest
    outputs:
      image_uri: ${{ steps.build-image.outputs.image_uri }}
    env:
      AWS_REGION: us-east-1
      AWS_ACCOUNT_ID: 978368259161
      ECR_REPOSITORY: webserver
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActions-deploy-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag & push to ECR
        id: build-image
        run: |
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-8)
          IMAGE_TAG="dev-${SHORT_SHA}"
          ECR_REGISTRY=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          IMAGE_NAME=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}

          echo "Building and pushing image with tag: $IMAGE_TAG"
          docker build -t $IMAGE_NAME:$IMAGE_TAG .
          docker push $IMAGE_NAME:$IMAGE_TAG

          echo "image_uri=$IMAGE_NAME:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Update Lambda function image
        run: |
          aws lambda update-function-code \
            --function-name migrate-ephemeral-db \
            --image-uri ${{ steps.build-image.outputs.image_uri }}

  run-migrations-lambda:
    name: Run Migrations via Lambda
    runs-on: ubuntu-latest
    needs: [provision-ephemeral-db, build-and-push-ecr]
    env:
      AWS_REGION: us-east-1
      AWS_ACCOUNT_ID: 978368259161
      DB_ENDPOINT: ${{ needs.provision-ephemeral-db.outputs.db_endpoint }}
      DB_SECRET_NAME: ${{ needs.provision-ephemeral-db.outputs.temp_secret_name }}
      DB_NAME: radsolutions
      DB_USER: postgres
      TEMP_S3_BUCKET: ${{ needs.provision-ephemeral-db.outputs.temp_s3_bucket }}
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActions-deploy-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Retrieve DB Password
        id: retrieve-db-password
        run: |
          DB_PASSWORD=$(aws secretsmanager get-secret-value --secret-id ${{ env.DB_SECRET_NAME }} --query SecretString --output text | jq -r .password)
          echo "::add-mask::$DB_PASSWORD"
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_ENV

      - name: Update Lambda Environment Variables
        run: |
          echo "Updating Lambda function environment variables..."
          aws lambda update-function-configuration \
            --function-name migrate-ephemeral-db \
            --environment "Variables={DATABASE_HOST=${{ env.DB_ENDPOINT }},DATABASE_NAME=${{ env.DB_NAME }},DATABASE_USER=${{ env.DB_USER }},DATABASE_PASSWORD=${{ env.DB_PASSWORD }},AWS_STORAGE_BUCKET_NAME=${{ env.TEMP_S3_BUCKET }},AWS_S3_REGION_NAME=${{ env.AWS_REGION }},DJANGO_SECRET_KEY=dummy-secret-for-lambda,DEBUG=True}"

      - name: Wait for Lambda to update
        run: |
          echo "Waiting for function configuration to be updated..."
          aws lambda wait function-updated --function-name migrate-ephemeral-db
          echo "Function updated."

      - name: Run Django migrations via Lambda
        run: |
          echo "Invoking Lambda function to run migrations..."
          aws lambda invoke \
            --function-name migrate-ephemeral-db \
            --invocation-type Event \
            --cli-binary-format raw-in-base64-out \
            output.json

          echo "Lambda invocation requested. Waiting for migrations to run..."
          sleep 120 # Wait for 2 minutes for migrations to complete

          cat output.json
          # Check if the invocation was accepted
          if ! grep -q '"StatusCode": 202' output.json; then
            echo "Lambda invocation failed!"
            exit 1
          fi
          echo "Migrations assumed to be complete."

  update-dev-environment:
    name: Update Dev App Runner Environment
    runs-on: ubuntu-latest
    needs: [provision-ephemeral-db, build-and-push-ecr, run-migrations-lambda]
    env:
      AWS_REGION: us-east-1
      AWS_ACCOUNT_ID: 978368259161
      APP_RUNNER_SERVICE_ARN: "arn:aws:apprunner:us-east-1:978368259161:service/radsolutions-web-dev/213e183c61af4e028e5cb956341429f9"
    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActions-deploy-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Resume App Runner if Paused
        run: |
          STATUS=$(aws apprunner describe-service --service-arn ${{ env.APP_RUNNER_SERVICE_ARN }} --query 'Service.Status' --output text)
          if [ "$STATUS" == "PAUSED" ]; then
            echo "Service is PAUSED. Resuming service..."
            aws apprunner resume-service --service-arn ${{ env.APP_RUNNER_SERVICE_ARN }}
            echo "Waiting for service to become RUNNING..."
            timeout 300 bash -c '
              while true; do
                CURRENT_STATUS=$(aws apprunner describe-service --service-arn "${{ env.APP_RUNNER_SERVICE_ARN }}" --query "Service.Status" --output text)
                if [ "$CURRENT_STATUS" == "RUNNING" ]; then
                  echo "Service is now RUNNING."
                  break
                fi
                echo "Current status: $CURRENT_STATUS. Waiting..."
                sleep 15
              done
            '
          else
            echo "Service is already in a non-paused state ($STATUS)."
          fi

      - name: Get App Runner Service URL
        id: app-runner-url
        run: |
          SERVICE_URL=$(aws apprunner describe-service --service-arn ${{ env.APP_RUNNER_SERVICE_ARN }} --query 'Service.ServiceUrl' --output text)
          echo "app_runner_url_host=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "App Runner URL Host: $SERVICE_URL"

      - name: Get DB Password from Temporary Secret
        id: db-password
        run: |
          echo "Retrieving password from temporary secret: ${{ needs.provision-ephemeral-db.outputs.temp_secret_name }}"
          DB_PASSWORD=$(aws secretsmanager get-secret-value --secret-id ${{ needs.provision-ephemeral-db.outputs.temp_secret_name }} --query SecretString --output text | jq -r .password)
          echo "::add-mask::$DB_PASSWORD"
          echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT

      - name: Update App Runner Service with New Image and Env Vars
        id: app-runner-update
        run: |
          echo "Updating App Runner service ${{ env.APP_RUNNER_SERVICE_ARN }}..."

          # Crear el archivo de configuración para update-service
          cat > update-service-config.json <<EOF
          {
              "ServiceArn": "${{ env.APP_RUNNER_SERVICE_ARN }}",
              "SourceConfiguration": {
                  "ImageRepository": {
                      "ImageIdentifier": "${{ needs.build-and-push-ecr.outputs.image_uri }}",
                      "ImageRepositoryType": "ECR",
                      "ImageConfiguration": {
                          "Port": "8000",
                          "RuntimeEnvironmentVariables": {
                              "DATABASE_HOST": "${{ needs.provision-ephemeral-db.outputs.db_endpoint }}",
                              "DATABASE_NAME": "postgres",
                              "DATABASE_USER": "postgres",
                              "DATABASE_PASSWORD": "${{ steps.db-password.outputs.db_password }}",
                              "DATABASE_PORT": "5432",
                              "AWS_STORAGE_BUCKET_NAME": "${{ needs.provision-ephemeral-db.outputs.temp_s3_bucket }}",
                              "AWS_S3_REGION_NAME": "${{ env.AWS_REGION }}",
                              "AWS_ACCESS_KEY_ID": "${{ secrets.AWS_ACCESS_KEY_ID_DEV }}",
                              "AWS_SECRET_ACCESS_KEY": "${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}",
                              "DJANGO_SECRET_KEY": "a-very-secure-secret-key-for-dev-env-from-gh-actions",
                              "USE_MOCK_STORAGE": "False",
                              "DEBUG": "True",
                              "DJANGO_LOG_LEVEL": "DEBUG",
                              "PYTHONUNBUFFERED": "1",
                              "AWS_APP_RUNNER_URL_HOST": "${{ steps.app-runner-url.outputs.app_runner_url_host }}"
                          }
                      }
                  }
              }
          }
          EOF

          aws apprunner update-service --cli-input-json file://update-service-config.json

          echo "Service update initiated for ${{ env.APP_RUNNER_SERVICE_ARN }}. App Runner will now start a new deployment."


  smoke-test:
    name: Smoke Test Dev Environment
    runs-on: ubuntu-latest
    needs: update-dev-environment
    env:
      APP_URL: ${{ needs.update-dev-environment.outputs.app_runner_url_host }}
    steps:
      - name: Smoke test health endpoint
        run: |
          echo "Waiting for service to be ready..."
          for i in {1..30}; do
            status=$(curl -s -o /dev/null -w "%{http_code}" $APP_URL/healthz) || status=0
            if [ "$status" == "200" ]; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i: returned $status. Retrying..."
            sleep 10
          done
          echo "Smoke test failed after 30 attempts."
          exit 1

  pause-dev-environment:
    name: Pause Dev App Runner Environment
    runs-on: ubuntu-latest
    needs: [smoke-test]
    if: always() # Asegura que este job se ejecute siempre
    env:
      AWS_REGION: us-east-1
      AWS_ACCOUNT_ID: 978368259161
      APP_RUNNER_SERVICE_ARN: "arn:aws:apprunner:us-east-1:978368259161:service/radsolutions-web-dev/213e183c61af4e028e5cb956341429f9"
    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActions-deploy-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for Service to be Ready and Pause
        run: |
          echo "Waiting for service to finish updating before pausing..."
          timeout 600 bash -c '
            while true; do
              STATUS=$(aws apprunner describe-service --service-arn "${{ env.APP_RUNNER_SERVICE_ARN }}" --query "Service.Status" --output text)
              echo "Current service status: $STATUS"
              if [ "$STATUS" == "RUNNING" ]; then
                echo "Service is RUNNING. Proceeding to pause."
                break
              elif [ "$STATUS" == "OPERATION_IN_PROGRESS" ]; then
                echo "Update is still in progress. Waiting..."
                sleep 20
              else
                echo "Service is in an unexpected state ($STATUS) and may not be pausable. Exiting wait loop."
                break
              fi
            done
          '

          echo "Pausing App Runner service ${{ env.APP_RUNNER_SERVICE_ARN }} to save costs."
          aws apprunner pause-service --service-arn ${{ env.APP_RUNNER_SERVICE_ARN }}
          echo "Service pause initiated."
